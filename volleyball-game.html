<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Volleyball Match - Cute Richard</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Comic Sans MS', 'Arial', sans-serif;
            background: linear-gradient(to bottom, #87CEEB 0%, #98D8E8 100%);
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: rgba(244, 164, 96, 0.9);
            color: white;
            padding: 15px;
            text-align: center;
            position: relative;
            z-index: 10;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }

        .header h1 {
            font-size: 1.8em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        .score-board {
            display: flex;
            justify-content: space-around;
            margin-top: 10px;
            font-size: 1.3em;
            font-weight: bold;
        }

        .player-score {
            padding: 5px 20px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 10px;
        }

        .game-container {
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        /* Modals */
        .modal {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 100;
            background: rgba(255, 255, 255, 0.98);
            padding: 40px;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            max-width: 500px;
            width: 90%;
        }

        .modal h2 {
            color: #f4a460;
            margin-bottom: 20px;
            font-size: 2em;
        }

        .modal p {
            color: #666;
            margin-bottom: 20px;
            font-size: 1.1em;
            line-height: 1.6;
        }

        .btn {
            background: linear-gradient(135deg, #f4a460, #d2691e);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 1.3em;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            transition: all 0.3s ease;
            font-family: 'Comic Sans MS', 'Arial', sans-serif;
            margin: 5px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 7px 20px rgba(0,0,0,0.4);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #999, #666);
        }

        .btn-small {
            font-size: 1em;
            padding: 10px 30px;
        }

        .status-message {
            font-size: 1.2em;
            color: #333;
            margin: 15px 0;
            font-weight: bold;
        }

        .waiting-spinner {
            display: inline-block;
            width: 40px;
            height: 40px;
            border: 4px solid rgba(244, 164, 96, 0.3);
            border-radius: 50%;
            border-top-color: #f4a460;
            animation: spin 1s ease-in-out infinite;
            margin: 20px auto;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .controls-hint {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px 30px;
            border-radius: 10px;
            font-size: 0.9em;
            z-index: 50;
            text-align: center;
        }

        /* Mobile Touch Controls */
        .mobile-controls {
            display: none;
            position: absolute;
            bottom: 20px;
            left: 0;
            right: 0;
            z-index: 60;
            padding: 0 20px;
        }

        .control-group {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 15px;
        }

        .direction-pad {
            display: flex;
            gap: 10px;
        }

        .control-btn {
            width: 70px;
            height: 70px;
            background: rgba(244, 164, 96, 0.8);
            border: 3px solid rgba(255, 255, 255, 0.5);
            border-radius: 15px;
            color: white;
            font-size: 1.5em;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            -webkit-user-select: none;
            user-select: none;
            touch-action: none;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }

        .control-btn:active {
            background: rgba(210, 105, 30, 0.9);
            transform: scale(0.95);
        }

        .jump-btn {
            width: 90px;
            height: 90px;
            background: rgba(255, 69, 0, 0.8);
            border-radius: 50%;
            font-size: 1.8em;
        }

        @media (max-width: 768px) {
            .mobile-controls {
                display: block;
            }

            .controls-hint {
                display: none !important;
            }
        }

        @media (max-width: 480px) {
            .header h1 {
                font-size: 1.3em;
            }
            .score-board {
                font-size: 1em;
            }
            .modal {
                padding: 20px;
            }
            .modal h2 {
                font-size: 1.5em;
            }
            .modal p {
                font-size: 0.9em;
            }
            .btn {
                font-size: 1.1em;
                padding: 12px 30px;
            }
            .control-btn {
                width: 60px;
                height: 60px;
                font-size: 1.3em;
            }
            .jump-btn {
                width: 75px;
                height: 75px;
                font-size: 1.5em;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üèê Richard's Volleyball Match üèê</h1>
        <div class="score-board">
            <div class="player-score">
                üê∂ <span id="player1Name">Player 1</span>: <span id="player1Score">0</span>
            </div>
            <div class="player-score">
                üêï <span id="player2Name">Player 2</span>: <span id="player2Score">0</span>
            </div>
        </div>
    </div>

    <div class="game-container">
        <canvas id="gameCanvas"></canvas>

        <!-- Matchmaking Screen -->
        <div class="modal" id="matchmakingScreen">
            <h2>üèê Choose Game Mode</h2>
            <p>Play against another player or AI!</p>
            <div class="status-message" id="matchStatus">Choose your mode</div>
            <div class="waiting-spinner" id="waitingSpinner" style="display: none;"></div>
            <button class="btn" id="findMatchBtn" onclick="findMatch()">üéÆ Find Player</button>
            <button class="btn" id="playAIBtn" onclick="playVsAI()">ü§ñ Play vs AI</button>
            <button class="btn btn-secondary btn-small" onclick="goBack()">Back to Menu</button>
        </div>

        <!-- Game Over Screen -->
        <div class="modal" id="gameOverModal">
            <h2 id="gameOverTitle">üéâ Victory! üéâ</h2>
            <p id="gameOverText" style="font-size: 1.5em; color: #333;">
                Winner: <span id="winnerName">Player</span><br>
                Final Score: <span id="player1NameFinal">Player 1</span> <span id="finalScoreText">11-9</span> <span id="player2NameFinal">Player 2</span>
            </p>
            <p id="highScoreMessage" style="font-size: 0.9em; color: #666; margin-top: 10px;"></p>

            <!-- Leaderboard -->
            <div id="leaderboard" style="margin: 20px 0; max-height: 300px; overflow-y: auto;">
                <h3 style="color: #f4a460; margin-bottom: 15px;">üèÜ Top 10 Players üèÜ</h3>
                <div id="leaderboardList" style="text-align: left; font-size: 0.9em;">
                    <p style="text-align: center; color: #999;">Loading leaderboard...</p>
                </div>
            </div>

            <button class="btn" onclick="playAgain()">Play Again</button>
            <button class="btn btn-secondary btn-small" onclick="goBack()">Back to Menu</button>
        </div>

        <div class="controls-hint" id="controlsHint" style="display: none;">
            üê∂ Brown: Arrow Keys + Space | üêï Black: A/D + W/Shift
        </div>

        <!-- Mobile Touch Controls -->
        <div class="mobile-controls" id="mobileControls" style="display: none;">
            <div class="control-group">
                <div class="direction-pad">
                    <div class="control-btn" id="leftBtn">‚óÄ</div>
                    <div class="control-btn" id="rightBtn">‚ñ∂</div>
                </div>
                <div class="control-btn jump-btn" id="jumpBtn">‚Üë</div>
            </div>
        </div>
    </div>

    <!-- Firebase SDK -->
    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
        import { getDatabase, ref, set, update, onValue, remove, get, push, onDisconnect } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js';

        const firebaseConfig = {
            apiKey: "AIzaSyDYrFZbFzAyoBBXJoX83Wq_CumP6NYie64",
            authDomain: "richardgame-67766.firebaseapp.com",
            databaseURL: "https://richardgame-67766-default-rtdb.firebaseio.com",
            projectId: "richardgame-67766",
            storageBucket: "richardgame-67766.firebasestorage.app",
            messagingSenderId: "886284486792",
            appId: "1:886284486792:web:f797fe51368861eab8f73d",
            measurementId: "G-D5K95ZN5GC"
        };

        const app = initializeApp(firebaseConfig);
        const database = getDatabase(app);

        // Export Firebase functions to window for use in main script
        window.firebaseDB = database;
        window.firebaseRef = ref;
        window.firebaseSet = set;
        window.firebaseUpdate = update;
        window.firebaseOnValue = onValue;
        window.firebaseRemove = remove;
        window.firebaseGet = get;
        window.firebasePush = push;
        window.firebaseOnDisconnect = onDisconnect;
    </script>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Resize canvas to fill container
        function resizeCanvas() {
            canvas.width = canvas.parentElement.clientWidth;
            canvas.height = canvas.parentElement.clientHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Get or create user ID
        let userId = localStorage.getItem('richardUserId');
        if (!userId) {
            userId = 'user_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            localStorage.setItem('richardUserId', userId);
        }

        // Get user data
        const userDataStr = sessionStorage.getItem('richardUserData') || localStorage.getItem('richardUserProfile');
        const userData = userDataStr ? JSON.parse(userDataStr) : { name: 'Player' };
        const userName = userData.name || 'Player';
        let userHighScore = userData.highScores?.volleyballGame || 0;

        // High Score Management
        async function saveHighScore(newScore) {
            if (newScore > userHighScore) {
                userHighScore = newScore;

                // Update sessionStorage
                const userDataStr = sessionStorage.getItem('richardUserData');
                if (userDataStr) {
                    const userData = JSON.parse(userDataStr);
                    userData.highScores = userData.highScores || {};
                    userData.highScores.volleyballGame = newScore;
                    sessionStorage.setItem('richardUserData', JSON.stringify(userData));
                }

                // Update localStorage
                const localData = JSON.parse(localStorage.getItem('richardUserProfile') || '{}');
                localData.highScores = localData.highScores || {};
                localData.highScores.volleyballGame = newScore;
                localStorage.setItem('richardUserProfile', JSON.stringify(localData));

                // Try to sync with Firebase
                try {
                    const userRef = window.firebaseRef(window.firebaseDB, 'users/' + userId + '/highScores');
                    await window.firebaseUpdate(userRef, {
                        volleyballGame: newScore,
                        lastPlayed: Date.now()
                    });

                    // Show high score message
                    const highScoreMsg = document.getElementById('highScoreMessage');
                    highScoreMsg.textContent = 'üéä NEW PERSONAL BEST! üéä';
                    highScoreMsg.style.color = '#ff6347';
                    highScoreMsg.style.fontWeight = 'bold';
                } catch (error) {
                    console.warn('Could not sync high score with Firebase:', error);
                }

                return true;
            } else if (userHighScore > 0) {
                const highScoreMsg = document.getElementById('highScoreMessage');
                highScoreMsg.textContent = `Your best score: ${userHighScore}`;
                highScoreMsg.style.color = '#666';
                highScoreMsg.style.fontWeight = 'normal';
            }
            return false;
        }

        async function loadLeaderboard() {
            const leaderboardList = document.getElementById('leaderboardList');

            try {
                const usersRef = window.firebaseRef(window.firebaseDB, 'users');
                const snapshot = await window.firebaseGet(usersRef);

                if (!snapshot.exists()) {
                    leaderboardList.innerHTML = '<p style="text-align: center; color: #999;">No leaderboard data available yet.</p>';
                    return;
                }

                const users = [];
                snapshot.forEach((childSnapshot) => {
                    const userData = childSnapshot.val();
                    const score = userData.highScores?.volleyballGame;

                    if (score && score > 0) {
                        users.push({
                            userId: childSnapshot.key,
                            name: userData.name || 'Anonymous',
                            score: score
                        });
                    }
                });

                users.sort((a, b) => b.score - a.score);
                const top10 = users.slice(0, 10);

                if (top10.length === 0) {
                    leaderboardList.innerHTML = '<p style="text-align: center; color: #999;">No scores recorded yet. Be the first!</p>';
                    return;
                }

                let html = '<div style="background: #f5f5f5; border-radius: 10px; padding: 10px;">';
                top10.forEach((user, index) => {
                    const isCurrentUser = user.userId === userId;
                    const medal = index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : index === 2 ? 'ü•â' : `${index + 1}.`;
                    const bgColor = isCurrentUser ? '#fffacd' : 'white';
                    const fontWeight = isCurrentUser ? 'bold' : 'normal';

                    html += `
                        <div style="background: ${bgColor}; padding: 8px 12px; margin: 5px 0; border-radius: 8px; display: flex; justify-content: space-between; align-items: center; font-weight: ${fontWeight};">
                            <span style="color: #f4a460; font-size: 1.1em; width: 30px;">${medal}</span>
                            <span style="flex: 1; color: #333;">${user.name}${isCurrentUser ? ' (You)' : ''}</span>
                            <span style="color: #666; font-weight: bold;">${user.score} pts</span>
                        </div>
                    `;
                });
                html += '</div>';

                leaderboardList.innerHTML = html;

            } catch (error) {
                console.warn('Could not load leaderboard:', error);
                leaderboardList.innerHTML = '<p style="text-align: center; color: #999;">Leaderboard unavailable (offline mode)</p>';
            }
        }

        // Game state
        let gameState = 'matchmaking'; // 'matchmaking', 'waiting', 'playing', 'finished'
        let currentGameId = null;
        let playerRole = null; // 'player1' or 'player2'
        let opponentName = 'Opponent';
        let isAIMode = false; // true if playing against AI

        // Game variables
        const COURT_WIDTH = 800;
        const COURT_HEIGHT = 400;
        const NET_WIDTH = 10;
        const NET_HEIGHT = 150;
        const GROUND_Y = COURT_HEIGHT - 50;
        const GRAVITY = 0.5;
        const JUMP_POWER = 12;
        const MOVE_SPEED = 5;
        const WIN_SCORE = 11;

        // Players
        let player1 = {
            x: 150,
            y: GROUND_Y - 45,
            width: 60,
            height: 45,
            velocityY: 0,
            onGround: true,
            score: 0,
            color: 'brown'
        };

        let player2 = {
            x: COURT_WIDTH - 150,
            y: GROUND_Y - 45,
            width: 60,
            height: 45,
            velocityY: 0,
            onGround: true,
            score: 0,
            color: 'black'
        };

        // Ball
        let ball = {
            x: COURT_WIDTH / 2,
            y: 100,
            radius: 15,
            velocityX: 0,
            velocityY: 0,
            active: false,
            serving: false,
            server: null // 'player1' or 'player2'
        };

        // Input tracking
        let keys = {};

        // Show matchmaking screen initially
        document.getElementById('matchmakingScreen').style.display = 'block';

        // Back to menu function
        function goBack() {
            if (currentGameId) {
                cleanupGame();
            }
            window.location.href = 'richard-index.html';
        }

        // ==========================================
        // MULTIPLAYER MATCHMAKING SYSTEM
        // ==========================================

        /*
         * HOW THE MATCHMAKING SYSTEM WORKS:
         *
         * 1. MATCHMAKING QUEUE
         *    - When a player clicks "Find Match", they join a queue in Firebase
         *    - Firebase structure: volleyball-matchmaking/{userId}
         *    - Stores: {userId, name, timestamp, status: 'waiting'}
         *
         * 2. FINDING OPPONENTS
         *    - We scan the queue for other waiting players
         *    - Match with the first available player (FIFO)
         *    - Remove both players from queue
         *
         * 3. CREATING GAME ROOM
         *    - Create unique game ID: game_{timestamp}_{random}
         *    - Firebase structure: volleyball-games/{gameId}
         *    - Store: {player1, player2, ball, gameState, scores}
         *
         * 4. REAL-TIME SYNC
         *    - Both players listen to the same game room
         *    - onValue() updates game state in real-time
         *    - Each player updates their own position
         *    - Ball physics calculated by server (player1)
         *
         * 5. DISCONNECT HANDLING
         *    - onDisconnect() removes player from queue automatically
         *    - If opponent disconnects during game, award win
         */

        async function findMatch() {
            try {
                document.getElementById('findMatchBtn').disabled = true;
                document.getElementById('matchStatus').textContent = 'Joining matchmaking...';
                document.getElementById('waitingSpinner').style.display = 'block';

                // Step 1: Add ourselves to the matchmaking queue
                const queueRef = window.firebaseRef(window.firebaseDB, `volleyball-matchmaking/${userId}`);
                await window.firebaseSet(queueRef, {
                    userId: userId,
                    name: userName,
                    timestamp: Date.now(),
                    status: 'waiting'
                });

                // Setup auto-removal on disconnect
                const onDisconnectRef = window.firebaseOnDisconnect(queueRef);
                await onDisconnectRef.remove();

                document.getElementById('matchStatus').textContent = 'Looking for opponent...';

                // Step 2: Look for available opponents
                const matchmakingRef = window.firebaseRef(window.firebaseDB, 'volleyball-matchmaking');
                const snapshot = await window.firebaseGet(matchmakingRef);

                let opponentId = null;
                let opponentData = null;

                if (snapshot.exists()) {
                    const players = snapshot.val();

                    // Find first available opponent (not ourselves)
                    for (const [playerId, playerData] of Object.entries(players)) {
                        if (playerId !== userId && playerData.status === 'waiting') {
                            opponentId = playerId;
                            opponentData = playerData;
                            break;
                        }
                    }
                }

                if (opponentId) {
                    // Step 3: Found opponent! Create game room
                    await createGameRoom(opponentId, opponentData);
                } else {
                    // Step 4: No opponent yet, wait for someone to join
                    document.getElementById('matchStatus').textContent = 'Waiting for opponent to join...';
                    waitForOpponent();
                }

            } catch (error) {
                console.error('Matchmaking error:', error);
                alert('Failed to join matchmaking. Please try again.');
                resetMatchmaking();
            }
        }

        // Wait for an opponent to join the queue
        function waitForOpponent() {
            const matchmakingRef = window.firebaseRef(window.firebaseDB, 'volleyball-matchmaking');

            // Listen for new players joining
            const unsubscribe = window.firebaseOnValue(matchmakingRef, async (snapshot) => {
                if (!snapshot.exists()) return;

                const players = snapshot.val();

                // Look for other waiting players
                for (const [playerId, playerData] of Object.entries(players)) {
                    if (playerId !== userId && playerData.status === 'waiting') {
                        // Found opponent!
                        unsubscribe(); // Stop listening
                        await createGameRoom(playerId, playerData);
                        break;
                    }
                }
            });
        }

        // Create a new game room for matched players
        async function createGameRoom(opponentId, opponentData) {
            try {
                document.getElementById('matchStatus').textContent = `Found opponent: ${opponentData.name}!`;

                // Check if a game room already exists with this opponent
                const matchmakingRef = window.firebaseRef(window.firebaseDB, 'volleyball-games');
                const gamesSnapshot = await window.firebaseGet(matchmakingRef);

                let existingGameId = null;

                if (gamesSnapshot.exists()) {
                    const games = gamesSnapshot.val();
                    // Look for a game where opponent is player1 and waiting for us
                    for (const [gameId, gameData] of Object.entries(games)) {
                        if (gameData.player1.userId === opponentId && !gameData.player2.userId) {
                            existingGameId = gameId;
                            break;
                        }
                    }
                }

                if (existingGameId) {
                    // Join existing game as player2
                    currentGameId = existingGameId;
                    playerRole = 'player2';
                    opponentName = opponentData.name;

                    const gameRef = window.firebaseRef(window.firebaseDB, `volleyball-games/${currentGameId}`);
                    await window.firebaseUpdate(gameRef, {
                        'player2': {
                            userId: userId,
                            name: userName,
                            x: player2.x,
                            y: player2.y,
                            velocityY: 0,
                            score: 0
                        },
                        gameState: 'playing'
                    });
                } else {
                    // Create new game as player1
                    currentGameId = 'game_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                    playerRole = 'player1';
                    opponentName = opponentData.name;

                    const gameRef = window.firebaseRef(window.firebaseDB, `volleyball-games/${currentGameId}`);
                    await window.firebaseSet(gameRef, {
                        gameId: currentGameId,
                        player1: {
                            userId: userId,
                            name: userName,
                            x: player1.x,
                            y: player1.y,
                            velocityY: 0,
                            score: 0
                        },
                        player2: {
                            userId: opponentId,
                            name: opponentData.name,
                            x: player2.x,
                            y: player2.y,
                            velocityY: 0,
                            score: 0
                        },
                        ball: {
                            x: ball.x,
                            y: ball.y,
                            velocityX: 0,
                            velocityY: 0,
                            active: true,
                            serving: true,
                            server: 'player1'
                        },
                        gameState: 'playing',
                        currentServer: 'player1',
                        createdAt: Date.now()
                    });
                }

                // Remove both players from matchmaking queue
                const queue1Ref = window.firebaseRef(window.firebaseDB, `volleyball-matchmaking/${userId}`);
                const queue2Ref = window.firebaseRef(window.firebaseDB, `volleyball-matchmaking/${opponentId}`);
                await window.firebaseRemove(queue1Ref);
                await window.firebaseRemove(queue2Ref);

                // Start the game
                setTimeout(() => {
                    startGame();
                }, 1500);

            } catch (error) {
                console.error('Error creating game room:', error);
                alert('Failed to create game. Please try again.');
                resetMatchmaking();
            }
        }

        // Play against AI
        function playVsAI() {
            isAIMode = true;
            playerRole = 'player1';
            opponentName = 'AI Bot';
            currentGameId = 'ai_game_' + Date.now();

            document.getElementById('matchmakingScreen').style.display = 'none';
            document.getElementById('player1Name').textContent = userName;
            document.getElementById('player2Name').textContent = opponentName;

            gameState = 'playing';

            // Show appropriate controls based on device
            if (window.innerWidth <= 768) {
                document.getElementById('mobileControls').style.display = 'block';
            } else {
                document.getElementById('controlsHint').style.display = 'block';
                setTimeout(() => {
                    document.getElementById('controlsHint').style.display = 'none';
                }, 5000);
            }

            // Start ball
            resetBall('player1');
        }

        // AI Logic
        function updateAI() {
            if (!isAIMode) return;

            // AI follows the ball when it's on their side
            const targetX = ball.x > COURT_WIDTH / 2 ? ball.x : COURT_WIDTH - 200;

            // Track if AI moved
            let aiMoved = false;
            const oldX = player2.x;

            // Move towards target
            if (player2.x < targetX - 10) {
                player2.x += MOVE_SPEED * 0.7; // AI is slightly slower
                aiMoved = true;
            } else if (player2.x > targetX + 10) {
                player2.x -= MOVE_SPEED * 0.7;
                aiMoved = true;
            }

            // If AI is serving and moved, launch the ball
            if (aiMoved && ball.serving && ball.server === 'player2') {
                launchServe('player2');
            }

            // Jump to hit ball if it's close
            if (ball.x > COURT_WIDTH / 2 && player2.onGround) {
                const dist = Math.sqrt(
                    Math.pow(ball.x - player2.x, 2) +
                    Math.pow(ball.y - (player2.y + 10), 2)
                );

                if (dist < 80 && ball.y < player2.y) {
                    player2.velocityY = -JUMP_POWER;
                    player2.onGround = false;
                }
            }

            updatePlayerPhysics(player2);
        }

        // Start the actual game
        function startGame() {
            document.getElementById('matchmakingScreen').style.display = 'none';

            // Update player names in scoreboard
            document.getElementById('player1Name').textContent = userName;
            document.getElementById('player2Name').textContent = opponentName;

            gameState = 'playing';

            // Show appropriate controls based on device
            if (window.innerWidth <= 768) {
                document.getElementById('mobileControls').style.display = 'block';
            } else {
                document.getElementById('controlsHint').style.display = 'block';
                setTimeout(() => {
                    document.getElementById('controlsHint').style.display = 'none';
                }, 5000);
            }

            // Start ball from player1's side
            resetBall('player1');

            // Listen for game updates from Firebase
            listenToGameUpdates();
        }

        // Listen to real-time game updates
        function listenToGameUpdates() {
            if (isAIMode) return; // Don't listen to Firebase in AI mode

            const gameRef = window.firebaseRef(window.firebaseDB, `volleyball-games/${currentGameId}`);

            window.firebaseOnValue(gameRef, (snapshot) => {
                if (!snapshot.exists()) {
                    // Game was deleted (opponent disconnected)
                    if (gameState === 'playing') {
                        alert('Opponent disconnected. You win!');
                        endGameAsWinner();
                    }
                    return;
                }

                const gameData = snapshot.val();

                // Update opponent position (not our own position!)
                if (playerRole === 'player1') {
                    // I am player1, so only update player2 (opponent)
                    if (gameData.player2) {
                        player2.x = gameData.player2.x;
                        player2.y = gameData.player2.y;
                        player2.velocityY = gameData.player2.velocityY || 0;
                    }
                } else if (playerRole === 'player2') {
                    // I am player2, so only update player1 (opponent)
                    if (gameData.player1) {
                        player1.x = gameData.player1.x;
                        player1.y = gameData.player1.y;
                        player1.velocityY = gameData.player1.velocityY || 0;
                    }
                }

                // Player1 receives ball updates from Firebase, Player2 calculates locally
                // Actually, let's have Player1 control ball and Player2 just receives updates
                if (playerRole === 'player2' && gameData.ball) {
                    ball.x = gameData.ball.x;
                    ball.y = gameData.ball.y;
                    ball.velocityX = gameData.ball.velocityX;
                    ball.velocityY = gameData.ball.velocityY;
                    ball.serving = gameData.ball.serving || false;
                    ball.server = gameData.ball.server || null;
                }

                // Update scores from Firebase
                if (gameData.player1) {
                    player1.score = gameData.player1.score;
                    document.getElementById('player1Score').textContent = gameData.player1.score;
                }
                if (gameData.player2) {
                    player2.score = gameData.player2.score;
                    document.getElementById('player2Score').textContent = gameData.player2.score;
                }

                // Check for game end
                if (gameData.gameState === 'finished') {
                    const winner = gameData.winner;
                    if (winner === userId) {
                        showGameOver(true, player1.score, player2.score);
                    } else {
                        showGameOver(false, player1.score, player2.score);
                    }
                }
            });
        }

        // Reset matchmaking state
        function resetMatchmaking() {
            document.getElementById('findMatchBtn').disabled = false;
            document.getElementById('matchStatus').textContent = 'Choose your mode';
            document.getElementById('waitingSpinner').style.display = 'none';
            gameState = 'matchmaking';
            isAIMode = false;
            playerRole = null;
            player1.score = 0;
            player2.score = 0;
        }

        // Play again function
        function playAgain() {
            if (currentGameId && !isAIMode) {
                cleanupGame();
            }

            // Reset player positions and scores
            player1.x = 150;
            player1.y = GROUND_Y - 45;
            player1.velocityY = 0;
            player1.onGround = true;
            player1.score = 0;

            player2.x = COURT_WIDTH - 150;
            player2.y = GROUND_Y - 45;
            player2.velocityY = 0;
            player2.onGround = true;
            player2.score = 0;

            document.getElementById('gameOverModal').style.display = 'none';
            document.getElementById('matchmakingScreen').style.display = 'block';
            resetMatchmaking();
        }

        // Cleanup game resources
        async function cleanupGame() {
            if (currentGameId) {
                try {
                    const gameRef = window.firebaseRef(window.firebaseDB, `volleyball-games/${currentGameId}`);
                    await window.firebaseRemove(gameRef);
                } catch (error) {
                    console.warn('Error cleaning up game:', error);
                }
                currentGameId = null;
            }
        }

        // Show game over screen
        async function showGameOver(won, score1, score2) {
            gameState = 'finished';

            if (won) {
                document.getElementById('gameOverTitle').textContent = 'üéâ You Won! üéâ';
            } else {
                document.getElementById('gameOverTitle').textContent = 'üò¢ You Lost';
            }

            // Get player names from scoreboard
            const player1NameText = document.getElementById('player1Name').textContent;
            const player2NameText = document.getElementById('player2Name').textContent;

            document.getElementById('finalScoreText').textContent = `${score1} - ${score2}`;
            document.getElementById('player1NameFinal').textContent = player1NameText;
            document.getElementById('player2NameFinal').textContent = player2NameText;
            document.getElementById('winnerName').textContent = won ? userName : opponentName;

            // Save high score and load leaderboard
            const finalScore = won ? score1 : score2; // Your score
            await saveHighScore(finalScore);
            await loadLeaderboard();

            document.getElementById('gameOverModal').style.display = 'block';
        }

        // End game when opponent disconnects
        function endGameAsWinner() {
            showGameOver(true, player1.score, player2.score);
            cleanupGame();
        }

        // ==========================================
        // INPUT HANDLING
        // ==========================================

        // Keyboard input
        document.addEventListener('keydown', (e) => {
            if (gameState !== 'playing') return;
            keys[e.key] = true;

            // Jump/Hit for Player 1 (Arrow Up or Space)
            if ((e.key === 'ArrowUp' || e.key === ' ') && playerRole === 'player1') {
                if (player1.onGround) {
                    player1.velocityY = -JUMP_POWER;
                    player1.onGround = false;
                }
            }

            // Jump/Hit for Player 2 (W or Shift)
            if ((e.key === 'w' || e.key === 'W' || e.key === 'Shift') && playerRole === 'player2') {
                if (player2.onGround) {
                    player2.velocityY = -JUMP_POWER;
                    player2.onGround = false;
                }
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        // ==========================================
        // MOBILE TOUCH CONTROLS
        // ==========================================

        // Touch state for mobile controls
        let touchState = {
            left: false,
            right: false,
            jump: false
        };

        // Left button
        const leftBtn = document.getElementById('leftBtn');
        leftBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            touchState.left = true;
        });
        leftBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            touchState.left = false;
        });
        leftBtn.addEventListener('touchcancel', (e) => {
            e.preventDefault();
            touchState.left = false;
        });

        // Right button
        const rightBtn = document.getElementById('rightBtn');
        rightBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            touchState.right = true;
        });
        rightBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            touchState.right = false;
        });
        rightBtn.addEventListener('touchcancel', (e) => {
            e.preventDefault();
            touchState.right = false;
        });

        // Jump button
        const jumpBtn = document.getElementById('jumpBtn');
        jumpBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            touchState.jump = true;

            // Trigger jump immediately
            if (gameState !== 'playing') return;

            if (isAIMode || playerRole === 'player1') {
                if (player1.onGround) {
                    player1.velocityY = -JUMP_POWER;
                    player1.onGround = false;
                }
            } else if (playerRole === 'player2') {
                if (player2.onGround) {
                    player2.velocityY = -JUMP_POWER;
                    player2.onGround = false;
                }
            }
        });
        jumpBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            touchState.jump = false;
        });
        jumpBtn.addEventListener('touchcancel', (e) => {
            e.preventDefault();
            touchState.jump = false;
        });

        // Apply touch movement in game loop
        function applyTouchControls() {
            if (gameState !== 'playing') return;

            if (isAIMode || playerRole === 'player1') {
                let moved = false;
                if (touchState.left) {
                    player1.x -= MOVE_SPEED;
                    moved = true;
                }
                if (touchState.right) {
                    player1.x += MOVE_SPEED;
                    moved = true;
                }
                // Launch ball if serving and moved
                if (moved && ball.serving && ball.server === 'player1') {
                    launchServe('player1');
                }
            } else if (playerRole === 'player2') {
                let moved = false;
                if (touchState.left) {
                    player2.x -= MOVE_SPEED;
                    moved = true;
                }
                if (touchState.right) {
                    player2.x += MOVE_SPEED;
                    moved = true;
                }
                // Launch ball if serving and moved
                if (moved && ball.serving && ball.server === 'player2') {
                    launchServe('player2');
                }
            }
        }

        // ==========================================
        // GAME PHYSICS & UPDATE
        // ==========================================

        function updatePlayerPhysics(player) {
            // Apply gravity
            if (!player.onGround) {
                player.velocityY += GRAVITY;
            }

            // Update vertical position
            player.y += player.velocityY;

            // Ground collision
            if (player.y >= GROUND_Y - player.height) {
                player.y = GROUND_Y - player.height;
                player.velocityY = 0;
                player.onGround = true;
            }

            // Keep within bounds (left/right)
            if (player === player1) {
                player.x = Math.max(30, Math.min(COURT_WIDTH / 2 - 50, player.x));
            } else {
                player.x = Math.max(COURT_WIDTH / 2 + 50, Math.min(COURT_WIDTH - 30, player.x));
            }
        }

        function updateBallPhysics() {
            if (!ball.active) return;

            // If ball is being served, stick it to the server
            if (ball.serving && ball.server) {
                const server = ball.server === 'player1' ? player1 : player2;
                ball.x = server.x;
                ball.y = server.y - 40; // Ball floats above the server
                ball.velocityX = 0;
                ball.velocityY = 0;
                return; // Don't apply physics while serving
            }

            // Apply gravity to ball
            ball.velocityY += GRAVITY * 0.8;

            // Update ball position
            ball.x += ball.velocityX;
            ball.y += ball.velocityY;

            // Net collision
            const netLeft = COURT_WIDTH / 2 - NET_WIDTH / 2;
            const netRight = COURT_WIDTH / 2 + NET_WIDTH / 2;
            const netTop = GROUND_Y - NET_HEIGHT;

            if (ball.x + ball.radius > netLeft && ball.x - ball.radius < netRight &&
                ball.y + ball.radius > netTop && ball.y - ball.radius < GROUND_Y) {
                // Hit the net
                ball.velocityX *= -0.5;
                if (ball.x < COURT_WIDTH / 2) {
                    ball.x = netLeft - ball.radius;
                } else {
                    ball.x = netRight + ball.radius;
                }
            }

            // Check if ball hit the ground (scoring)
            if (ball.y + ball.radius >= GROUND_Y) {
                if (ball.x < COURT_WIDTH / 2) {
                    // Ball landed on player1's side - player2 scores
                    scorePoint('player2');
                } else {
                    // Ball landed on player2's side - player1 scores
                    scorePoint('player1');
                }
                return;
            }

            // Ball out of bounds (sides)
            if (ball.x < 0 || ball.x > COURT_WIDTH) {
                if (ball.x < COURT_WIDTH / 2) {
                    scorePoint('player2');
                } else {
                    scorePoint('player1');
                }
                return;
            }

            // Player collision
            checkBallPlayerCollision(player1);
            checkBallPlayerCollision(player2);
        }

        function checkBallPlayerCollision(player) {
            const dist = Math.sqrt(
                Math.pow(ball.x - player.x, 2) +
                Math.pow(ball.y - (player.y + 10), 2)
            );

            if (dist < ball.radius + 25) {
                // Ball hit player!
                const angle = Math.atan2(ball.y - (player.y + 10), ball.x - player.x);
                const power = 8;

                ball.velocityX = Math.cos(angle) * power;
                ball.velocityY = Math.sin(angle) * power - 3; // Add upward boost

                // Move ball away from player to prevent multiple hits
                ball.x = player.x + Math.cos(angle) * (ball.radius + 26);
                ball.y = (player.y + 10) + Math.sin(angle) * (ball.radius + 26);
            }
        }

        function scorePoint(scoringPlayer) {
            if (scoringPlayer === 'player1') {
                player1.score++;
            } else {
                player2.score++;
            }

            // Update score display immediately (especially important for AI mode)
            document.getElementById('player1Score').textContent = player1.score;
            document.getElementById('player2Score').textContent = player2.score;

            // Check for win condition
            if (player1.score >= WIN_SCORE || player2.score >= WIN_SCORE) {
                endGame();
                return;
            }

            // Reset ball
            resetBall(scoringPlayer === 'player1' ? 'player1' : 'player2');

            // Update scores in Firebase (only for online multiplayer, not AI mode)
            if (currentGameId && !isAIMode) {
                const gameRef = window.firebaseRef(window.firebaseDB, `volleyball-games/${currentGameId}`);
                window.firebaseUpdate(gameRef, {
                    'player1/score': player1.score,
                    'player2/score': player2.score
                });
            }
        }

        function resetBall(server) {
            const servingPlayer = server === 'player1' ? player1 : player2;
            ball.x = servingPlayer.x;
            ball.y = servingPlayer.y - 40;
            ball.velocityX = 0;
            ball.velocityY = 0;
            ball.active = true;
            ball.serving = true; // Ball is in serving mode
            ball.server = server; // Track who is serving
        }

        // Launch ball when server moves
        function launchServe(server) {
            if (!ball.serving) return;

            ball.serving = false;

            // Launch ball upward and toward the opponent
            if (server === 'player1') {
                ball.velocityX = 4; // Move toward player2's side
                ball.velocityY = -8; // Launch upward
            } else {
                ball.velocityX = -4; // Move toward player1's side
                ball.velocityY = -8; // Launch upward
            }
        }

        async function endGame() {
            gameState = 'finished';

            const winner = player1.score >= WIN_SCORE ? player1 : player2;

            if (isAIMode) {
                // In AI mode, show game over directly
                const wonGame = winner === player1;
                showGameOver(wonGame, player1.score, player2.score);
            } else {
                // In multiplayer mode, update Firebase
                const winnerId = playerRole === 'player1' ?
                    (winner === player1 ? userId : opponentName) :
                    (winner === player2 ? userId : opponentName);

                if (currentGameId) {
                    const gameRef = window.firebaseRef(window.firebaseDB, `volleyball-games/${currentGameId}`);
                    await window.firebaseUpdate(gameRef, {
                        gameState: 'finished',
                        winner: winnerId
                    });
                }
                // Show will be triggered by Firebase listener
            }
        }

        // Game loop
        function update() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Scale canvas to fit screen while maintaining aspect ratio
            const scaleX = canvas.width / COURT_WIDTH;
            const scaleY = canvas.height / COURT_HEIGHT;
            const scale = Math.min(scaleX, scaleY);

            ctx.save();
            ctx.scale(scale, scale);

            // Center the court if needed
            const offsetX = (canvas.width / scale - COURT_WIDTH) / 2;
            const offsetY = (canvas.height / scale - COURT_HEIGHT) / 2;
            ctx.translate(offsetX, offsetY);

            // Draw court
            drawCourt();

            // Only update physics if playing
            if (gameState === 'playing') {
                // Apply touch controls first
                applyTouchControls();

                if (isAIMode) {
                    // AI Mode - player controls player1, AI controls player2
                    let player1Moved = false;
                    if (keys['ArrowLeft']) {
                        player1.x -= MOVE_SPEED;
                        player1Moved = true;
                    }
                    if (keys['ArrowRight']) {
                        player1.x += MOVE_SPEED;
                        player1Moved = true;
                    }

                    // Launch ball if player1 is serving and moved
                    if (player1Moved && ball.serving && ball.server === 'player1') {
                        launchServe('player1');
                    }

                    updatePlayerPhysics(player1);
                    updateAI(); // Update AI opponent
                    updateBallPhysics(); // Update ball in AI mode
                } else {
                    // Multiplayer Mode
                    if (playerRole === 'player1') {
                        let player1Moved = false;
                        if (keys['ArrowLeft']) {
                            player1.x -= MOVE_SPEED;
                            player1Moved = true;
                        }
                        if (keys['ArrowRight']) {
                            player1.x += MOVE_SPEED;
                            player1Moved = true;
                        }

                        // Launch ball if player1 is serving and moved
                        if (player1Moved && ball.serving && ball.server === 'player1') {
                            launchServe('player1');
                        }

                        updatePlayerPhysics(player1);

                        // Update my position in Firebase
                        if (currentGameId) {
                            const gameRef = window.firebaseRef(window.firebaseDB, `volleyball-games/${currentGameId}`);
                            window.firebaseUpdate(gameRef, {
                                'player1/x': player1.x,
                                'player1/y': player1.y,
                                'player1/velocityY': player1.velocityY
                            });
                        }
                    } else if (playerRole === 'player2') {
                        let player2Moved = false;
                        if (keys['a'] || keys['A']) {
                            player2.x -= MOVE_SPEED;
                            player2Moved = true;
                        }
                        if (keys['d'] || keys['D']) {
                            player2.x += MOVE_SPEED;
                            player2Moved = true;
                        }

                        // Launch ball if player2 is serving and moved
                        if (player2Moved && ball.serving && ball.server === 'player2') {
                            launchServe('player2');
                        }

                        updatePlayerPhysics(player2);

                        // Update my position in Firebase
                        if (currentGameId) {
                            const gameRef = window.firebaseRef(window.firebaseDB, `volleyball-games/${currentGameId}`);
                            window.firebaseUpdate(gameRef, {
                                'player2/x': player2.x,
                                'player2/y': player2.y,
                                'player2/velocityY': player2.velocityY
                            });
                        }
                    }

                    // Player1 controls ball physics (acts as server)
                    if (playerRole === 'player1') {
                        updateBallPhysics();

                        // Update ball in Firebase
                        if (currentGameId) {
                            const gameRef = window.firebaseRef(window.firebaseDB, `volleyball-games/${currentGameId}`);
                            window.firebaseUpdate(gameRef, {
                                'ball/x': ball.x,
                                'ball/y': ball.y,
                                'ball/velocityX': ball.velocityX,
                                'ball/velocityY': ball.velocityY,
                                'ball/serving': ball.serving,
                                'ball/server': ball.server
                            });
                        }
                    }
                }
            }

            // Draw players
            drawPlayer(player1, player1.color);
            drawPlayer(player2, player2.color);

            // Draw ball
            drawBall();

            ctx.restore();

            requestAnimationFrame(update);
        }

        function drawCourt() {
            // Ground
            ctx.fillStyle = '#90EE90';
            ctx.fillRect(0, GROUND_Y, COURT_WIDTH, 50);

            // Net
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(COURT_WIDTH / 2 - NET_WIDTH / 2, GROUND_Y - NET_HEIGHT, NET_WIDTH, NET_HEIGHT);

            // Net mesh pattern
            ctx.strokeStyle = '#CCCCCC';
            ctx.lineWidth = 1;
            for (let i = 0; i < NET_HEIGHT; i += 10) {
                ctx.beginPath();
                ctx.moveTo(COURT_WIDTH / 2 - NET_WIDTH / 2, GROUND_Y - NET_HEIGHT + i);
                ctx.lineTo(COURT_WIDTH / 2 + NET_WIDTH / 2, GROUND_Y - NET_HEIGHT + i);
                ctx.stroke();
            }
        }

        function drawPlayer(player, color) {
            ctx.save();

            // Body (oval)
            ctx.fillStyle = color === 'brown' ? '#8B4513' : '#2F2F2F';
            ctx.beginPath();
            ctx.ellipse(player.x, player.y + 20, 30, 22, 0, 0, Math.PI * 2);
            ctx.fill();

            // Head (circle)
            ctx.beginPath();
            ctx.arc(player.x, player.y, 20, 0, Math.PI * 2);
            ctx.fill();

            // Ears (triangles)
            ctx.fillStyle = color === 'brown' ? '#A0522D' : '#1F1F1F';
            ctx.beginPath();
            ctx.moveTo(player.x - 15, player.y - 10);
            ctx.lineTo(player.x - 20, player.y - 25);
            ctx.lineTo(player.x - 10, player.y - 15);
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(player.x + 15, player.y - 10);
            ctx.lineTo(player.x + 20, player.y - 25);
            ctx.lineTo(player.x + 10, player.y - 15);
            ctx.fill();

            // Eyes
            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.arc(player.x - 8, player.y - 5, 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(player.x + 8, player.y - 5, 3, 0, Math.PI * 2);
            ctx.fill();

            // Nose
            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.arc(player.x, player.y + 5, 4, 0, Math.PI * 2);
            ctx.fill();

            // White chest (for black corgi)
            if (color === 'black') {
                ctx.fillStyle = '#FFFFFF';
                ctx.beginPath();
                ctx.ellipse(player.x, player.y + 25, 15, 12, 0, 0, Math.PI * 2);
                ctx.fill();
            }

            // Legs (simple rectangles)
            ctx.fillStyle = color === 'brown' ? '#8B4513' : '#2F2F2F';
            ctx.fillRect(player.x - 20, player.y + 35, 10, 10);
            ctx.fillRect(player.x + 10, player.y + 35, 10, 10);

            ctx.restore();
        }

        function drawBall() {
            ctx.save();

            // If serving, add a glow effect
            if (ball.serving) {
                ctx.shadowColor = '#FFD700';
                ctx.shadowBlur = 15;
            }

            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
            ctx.fill();

            // Ball pattern
            ctx.strokeStyle = ball.serving ? '#FFD700' : '#DDDDDD';
            ctx.lineWidth = ball.serving ? 3 : 2;
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
            ctx.stroke();

            ctx.restore();
        }

        // Start game loop
        update();
    </script>
</body>
</html>
