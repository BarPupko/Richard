<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>House & Garden - Cute Richard</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Comic Sans MS', 'Arial', sans-serif;
            background: linear-gradient(to right, #8B4513 0%, #8B4513 50%, #90EE90 50%, #90EE90 100%);
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: rgba(86, 171, 47, 0.9);
            color: white;
            padding: 15px;
            text-align: center;
            position: relative;
            z-index: 10;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }

        .header h1 {
            font-size: 1.8em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        .score-board {
            display: flex;
            justify-content: space-around;
            margin-top: 10px;
            font-size: 1.1em;
        }

        .game-container {
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        .modal {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 100;
            background: rgba(255, 255, 255, 0.98);
            padding: 40px;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            max-width: 500px;
            width: 90%;
        }

        .modal h2 {
            color: #56ab2f;
            margin-bottom: 20px;
            font-size: 2em;
        }

        .modal p {
            color: #666;
            margin-bottom: 20px;
            font-size: 1.1em;
        }

        .btn {
            background: linear-gradient(135deg, #56ab2f, #a8e063);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 1.3em;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            transition: all 0.3s ease;
            font-family: 'Comic Sans MS', 'Arial', sans-serif;
            margin: 5px;
        }

        .btn:hover {
            transform: scale(1.05);
            box-shadow: 0 7px 20px rgba(0,0,0,0.4);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #667eea, #764ba2);
        }

        .btn-small {
            padding: 10px 25px;
            font-size: 1.1em;
        }

        .controls-hint {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 15px 25px;
            border-radius: 15px;
            z-index: 5;
            font-size: 1.1em;
        }

        @media (max-width: 480px) {
            .header h1 {
                font-size: 1.4em;
            }
            .score-board {
                font-size: 0.9em;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üè† Richard's House & Garden üå≥</h1>
        <div class="score-board">
            <div>Player: <span id="playerName">...</span></div>
            <div>Items: <span id="itemsCollected">0</span>/10 üì¶</div>
            <div>Lives: <span id="lives">3</span> ‚ù§Ô∏è</div>
            <div>Time: <span id="timer">0</span>s ‚è±Ô∏è</div>
        </div>
    </div>

    <div class="game-container">
        <canvas id="gameCanvas"></canvas>

        <!-- Start Screen -->
        <div class="modal" id="startScreen">
            <h2 style="font-size: 1.5em; margin-bottom: 15px;">üê∂ Fetch His Toys! üéæ</h2>
            <p style="font-size: 0.95em; line-height: 1.4; margin-bottom: 15px;">
            üè† Grab toys from the house<br>
            üö™ Wait for the door to open<br>
            üå≥ Bring them to the garden<br>
            ‚ù§Ô∏è You have 3 lives!<br>
            <strong>Controls:</strong> Click/Tap or Arrow Keys</p>
            <button class="btn" onclick="startGame()">Start Game!</button>
            <button class="btn btn-secondary btn-small" onclick="goBack()">Back to Menu</button>
        </div>

        <!-- Game Over Modal -->
        <div class="modal" id="gameOverModal">
            <h2 id="gameOverTitle">üéâ Great Job! üéâ</h2>
            <p id="gameOverText" style="font-size: 1.5em; color: #333;">
                Final Time: <span id="finalTime">0</span> seconds! üèÜ<br>
                <span id="highScoreMessage" style="font-size: 0.8em;"></span>
            </p>

            <!-- Leaderboard -->
            <div id="leaderboard" style="margin: 20px 0; max-height: 300px; overflow-y: auto;">
                <h3 style="color: #56ab2f; margin-bottom: 15px;">üèÜ Top 10 Fastest Times üèÜ</h3>
                <div id="leaderboardList" style="text-align: left; font-size: 0.9em;">
                    <p style="text-align: center; color: #999;">Loading leaderboard...</p>
                </div>
            </div>

            <button class="btn" onclick="restartGame()">Play Again</button>
            <button class="btn btn-secondary btn-small" onclick="goBack()">Back to Menu</button>
        </div>

        <div class="controls-hint" id="controlsHint">
            Click/Tap to move Richard or use Arrow Keys ‚å®Ô∏è
        </div>
    </div>

    <!-- Firebase SDK -->
    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
        import { getDatabase, ref, update, get } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js';

        const firebaseConfig = {
            apiKey: "AIzaSyDYrFZbFzAyoBBXJoX83Wq_CumP6NYie64",
            authDomain: "richardgame-67766.firebaseapp.com",
            databaseURL: "https://richardgame-67766-default-rtdb.firebaseio.com",
            projectId: "richardgame-67766",
            storageBucket: "richardgame-67766.firebasestorage.app",
            messagingSenderId: "886284486792",
            appId: "1:886284486792:web:f797fe51368861eab8f73d",
            measurementId: "G-D5K95ZN5GC"
        };

        const app = initializeApp(firebaseConfig);
        const database = getDatabase(app);

        window.firebaseDB = database;
        window.firebaseRef = ref;
        window.firebaseUpdate = update;
        window.firebaseGet = get;

        initializeUser();
    </script>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight - document.querySelector('.header').offsetHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // User management
        let userId = null;
        let userName = 'Player';
        let userHighScore = Infinity;

        function initializeUser() {
            const userDataStr = sessionStorage.getItem('richardUserData');
            if (userDataStr) {
                try {
                    const userData = JSON.parse(userDataStr);
                    userId = userData.userId;
                    userName = userData.userName || 'Player';
                    userHighScore = userData.highScores?.houseGarden || Infinity;
                    document.getElementById('playerName').textContent = userName;
                } catch (error) {
                    console.error('Error parsing user data:', error);
                }
            } else {
                alert('Please start from the main menu!');
                window.location.href = 'richard-index.html';
                return;
            }

            document.getElementById('startScreen').style.display = 'block';
        }

        async function saveHighScore(timeTaken) {
            if (timeTaken < userHighScore) {
                userHighScore = timeTaken;

                const userDataStr = sessionStorage.getItem('richardUserData');
                if (userDataStr) {
                    const userData = JSON.parse(userDataStr);
                    userData.highScores = userData.highScores || {};
                    userData.highScores.houseGarden = timeTaken;
                    sessionStorage.setItem('richardUserData', JSON.stringify(userData));
                }

                const localData = JSON.parse(localStorage.getItem('richardUserProfile') || '{}');
                localData.highScores = localData.highScores || {};
                localData.highScores.houseGarden = timeTaken;
                localStorage.setItem('richardUserProfile', JSON.stringify(localData));

                try {
                    const userRef = window.firebaseRef(window.firebaseDB, 'users/' + userId + '/highScores');
                    await window.firebaseUpdate(userRef, {
                        houseGarden: timeTaken,
                        lastPlayed: Date.now()
                    });
                } catch (error) {
                    console.warn('Could not sync high score with Firebase:', error);
                }

                return true;
            }
            return false;
        }

        // Load and display leaderboard
        async function loadLeaderboard() {
            const leaderboardList = document.getElementById('leaderboardList');

            try {
                // Fetch all users
                const usersRef = window.firebaseRef(window.firebaseDB, 'users');
                const snapshot = await window.firebaseGet(usersRef);

                if (!snapshot.exists()) {
                    leaderboardList.innerHTML = '<p style="text-align: center; color: #999;">No leaderboard data available yet.</p>';
                    return;
                }

                // Convert to array and filter users with houseGarden scores
                const users = [];
                snapshot.forEach((childSnapshot) => {
                    const userData = childSnapshot.val();
                    const time = userData.highScores?.houseGarden;

                    if (time && time > 0) {
                        users.push({
                            userId: childSnapshot.key,
                            name: userData.name || 'Anonymous',
                            time: time
                        });
                    }
                });

                // Sort by time (lowest time is best)
                users.sort((a, b) => a.time - b.time);

                // Take top 10
                const top10 = users.slice(0, 10);

                if (top10.length === 0) {
                    leaderboardList.innerHTML = '<p style="text-align: center; color: #999;">No times recorded yet. Be the first!</p>';
                    return;
                }

                // Display leaderboard
                let html = '<div style="background: #f5f5f5; border-radius: 10px; padding: 10px;">';
                top10.forEach((user, index) => {
                    const isCurrentUser = user.userId === userId;
                    const medal = index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : index === 2 ? 'ü•â' : `${index + 1}.`;
                    const bgColor = isCurrentUser ? '#fffacd' : 'white';
                    const fontWeight = isCurrentUser ? 'bold' : 'normal';

                    html += `
                        <div style="background: ${bgColor}; padding: 8px 12px; margin: 5px 0; border-radius: 8px; display: flex; justify-content: space-between; align-items: center; font-weight: ${fontWeight};">
                            <span style="color: #56ab2f; font-size: 1.1em; width: 30px;">${medal}</span>
                            <span style="flex: 1; color: #333;">${user.name}${isCurrentUser ? ' (You)' : ''}</span>
                            <span style="color: #666; font-weight: bold;">${user.time}s</span>
                        </div>
                    `;
                });
                html += '</div>';

                leaderboardList.innerHTML = html;

            } catch (error) {
                console.warn('Could not load leaderboard:', error);
                leaderboardList.innerHTML = '<p style="text-align: center; color: #999;">Could not load leaderboard. Please check your connection.</p>';
            }
        }

        // Game variables
        let gameRunning = false;
        let itemsCollected = 0;
        let totalItems = 10;
        let gameTimer = 0;
        let timerInterval = null;
        let lives = 3;

        // Background images
        let bgImageLandscape = new Image();
        let bgImagePortrait = new Image();
        let imagesLoaded = 0;

        bgImageLandscape.src = 'background/landscape.png';
        bgImagePortrait.src = 'background/phone.png';

        bgImageLandscape.onload = () => {
            imagesLoaded++;
            if (imagesLoaded === 2) console.log('Background images loaded');
        };

        bgImagePortrait.onload = () => {
            imagesLoaded++;
            if (imagesLoaded === 2) console.log('Background images loaded');
        };

        // Door state (sliding door position)
        let doorOpen = false;
        let doorTimer = 0;
        let nextDoorChange = 2000; // milliseconds
        let doorSlidePos = 0; // 0 = closed, 1 = fully open
        let doorAnimating = false;

        // Temperature (random between 60-85¬∞F)
        let temperature = Math.floor(Math.random() * 26) + 60;

        // Richard position
        let richard = {
            x: canvas.width * 0.75, // Start in garden
            y: canvas.height / 2,
            targetX: canvas.width * 0.75,
            targetY: canvas.height / 2,
            width: 60,
            height: 45,
            speed: 0.15,
            carryingItem: false,
            prevX: canvas.width * 0.75 // Track previous x position
        };

        // Items in house
        let houseItems = [];
        let collectedToys = []; // Toys that have been delivered to the box

        // Generate random items in house
        function generateItems() {
            houseItems = [];
            collectedToys = [];
            const houseLeft = 50;
            const houseRight = canvas.width / 2 - 100;
            const houseTop = 50;
            const houseBottom = canvas.height - 50;

            const toyTypes = ['bone', 'ball', 'fish', 'liberty'];

            for (let i = 0; i < totalItems; i++) {
                houseItems.push({
                    x: houseLeft + Math.random() * (houseRight - houseLeft),
                    y: houseTop + Math.random() * (houseBottom - houseTop),
                    collected: false,
                    type: toyTypes[Math.floor(Math.random() * toyTypes.length)]
                });
            }

            console.log('Generated ' + houseItems.length + ' toys');
        }

        // Draw Richard
        function drawRichard(x, y) {
            ctx.save();

            // Body
            ctx.fillStyle = '#d4a373';
            ctx.beginPath();
            ctx.ellipse(x, y, 30, 18, 0, 0, Math.PI * 2);
            ctx.fill();

            // White belly
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.ellipse(x, y + 3, 18, 11, 0, 0, Math.PI * 2);
            ctx.fill();

            // Head
            ctx.fillStyle = '#d4a373';
            ctx.beginPath();
            ctx.ellipse(x - 18, y - 7, 15, 13, 0, 0, Math.PI * 2);
            ctx.fill();

            // White face
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.ellipse(x - 18, y - 6, 9, 7, 0, 0, Math.PI * 2);
            ctx.fill();

            // Eyes
            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.arc(x - 22, y - 9, 2, 0, Math.PI * 2);
            ctx.arc(x - 14, y - 9, 2, 0, Math.PI * 2);
            ctx.fill();

            // Nose
            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.arc(x - 18, y - 4, 3, 0, Math.PI * 2);
            ctx.fill();

            // Tail
            ctx.strokeStyle = '#d4a373';
            ctx.lineWidth = 5;
            ctx.beginPath();
            ctx.moveTo(x + 30, y);
            ctx.quadraticCurveTo(x + 37, y - 7, x + 33, y - 15);
            ctx.stroke();

            // If carrying item, draw toy above
            if (richard.carryingItem) {
                drawToy(x, y - 30, richard.carryingItem);
            }

            ctx.restore();
        }

        // Draw dog toy based on type
        function drawToy(x, y, type, scale = 1) {
            ctx.save();

            if (type === 'bone') {
                // Draw a bone
                ctx.fillStyle = '#F5DEB3';
                // Left end
                ctx.beginPath();
                ctx.arc(x - 12 * scale, y - 3 * scale, 4 * scale, 0, Math.PI * 2);
                ctx.arc(x - 12 * scale, y + 3 * scale, 4 * scale, 0, Math.PI * 2);
                ctx.fill();
                // Right end
                ctx.beginPath();
                ctx.arc(x + 12 * scale, y - 3 * scale, 4 * scale, 0, Math.PI * 2);
                ctx.arc(x + 12 * scale, y + 3 * scale, 4 * scale, 0, Math.PI * 2);
                ctx.fill();
                // Middle
                ctx.fillRect(x - 10 * scale, y - 2 * scale, 20 * scale, 4 * scale);

            } else if (type === 'ball') {
                // Draw a tennis ball
                ctx.fillStyle = '#CCFF00';
                ctx.beginPath();
                ctx.arc(x, y, 10 * scale, 0, Math.PI * 2);
                ctx.fill();
                // Tennis ball lines
                ctx.strokeStyle = '#FFFFFF';
                ctx.lineWidth = 2 * scale;
                ctx.beginPath();
                ctx.arc(x, y, 10 * scale, Math.PI * 0.3, Math.PI * 0.7);
                ctx.arc(x, y, 10 * scale, Math.PI * 1.3, Math.PI * 1.7);
                ctx.stroke();

            } else if (type === 'fish') {
                // Draw a toy fish
                ctx.fillStyle = '#4169E1';
                // Body
                ctx.beginPath();
                ctx.ellipse(x, y, 12 * scale, 6 * scale, 0, 0, Math.PI * 2);
                ctx.fill();
                // Tail
                ctx.beginPath();
                ctx.moveTo(x + 12 * scale, y);
                ctx.lineTo(x + 18 * scale, y - 5 * scale);
                ctx.lineTo(x + 18 * scale, y + 5 * scale);
                ctx.closePath();
                ctx.fill();
                // Eye
                ctx.fillStyle = '#000000';
                ctx.beginPath();
                ctx.arc(x - 6 * scale, y - 2 * scale, 2 * scale, 0, Math.PI * 2);
                ctx.fill();

            } else if (type === 'liberty') {
                // Draw a Statue of Liberty toy
                // Base
                ctx.fillStyle = '#A9A9A9';
                ctx.fillRect(x - 8 * scale, y + 8 * scale, 16 * scale, 4 * scale);
                // Body/robe
                ctx.fillStyle = '#7CFC00';
                ctx.beginPath();
                ctx.moveTo(x, y - 10 * scale);
                ctx.lineTo(x - 6 * scale, y + 8 * scale);
                ctx.lineTo(x + 6 * scale, y + 8 * scale);
                ctx.closePath();
                ctx.fill();
                // Head
                ctx.fillStyle = '#7CFC00';
                ctx.beginPath();
                ctx.arc(x, y - 12 * scale, 3 * scale, 0, Math.PI * 2);
                ctx.fill();
                // Crown spikes
                ctx.fillStyle = '#FFD700';
                ctx.beginPath();
                ctx.moveTo(x - 4 * scale, y - 13 * scale);
                ctx.lineTo(x - 3 * scale, y - 18 * scale);
                ctx.lineTo(x - 2 * scale, y - 13 * scale);
                ctx.lineTo(x - 1 * scale, y - 19 * scale);
                ctx.lineTo(x, y - 13 * scale);
                ctx.lineTo(x + 1 * scale, y - 19 * scale);
                ctx.lineTo(x + 2 * scale, y - 13 * scale);
                ctx.lineTo(x + 3 * scale, y - 18 * scale);
                ctx.lineTo(x + 4 * scale, y - 13 * scale);
                ctx.closePath();
                ctx.fill();
                // Torch (right arm)
                ctx.strokeStyle = '#FFD700';
                ctx.lineWidth = 2 * scale;
                ctx.beginPath();
                ctx.moveTo(x, y - 8 * scale);
                ctx.lineTo(x + 8 * scale, y - 14 * scale);
                ctx.stroke();
                // Flame
                ctx.fillStyle = '#FF6347';
                ctx.beginPath();
                ctx.moveTo(x + 8 * scale, y - 14 * scale);
                ctx.lineTo(x + 7 * scale, y - 18 * scale);
                ctx.lineTo(x + 9 * scale, y - 18 * scale);
                ctx.closePath();
                ctx.fill();
            }

            ctx.restore();
        }

        // Draw door
        // Draw vertical sliding door (like a window slider)
        function drawSlidingDoor() {
            const doorX = canvas.width / 2 - 35;
            const doorFrameTop = canvas.height / 2 - 80;
            const doorFrameHeight = 160;
            const doorWidth = 70;

            ctx.save();

            // Door frame/track
            ctx.fillStyle = '#8B7355';
            ctx.fillRect(doorX - 5, doorFrameTop, doorWidth + 10, doorFrameHeight);
            ctx.strokeStyle = '#654321';
            ctx.lineWidth = 3;
            ctx.strokeRect(doorX - 5, doorFrameTop, doorWidth + 10, doorFrameHeight);

            // Calculate door panel position (slides down when opening)
            const doorPanelHeight = doorFrameHeight * 0.6; // Door covers 60% of frame
            const slideDistance = doorFrameHeight - doorPanelHeight; // Distance it can slide
            const doorPanelY = doorFrameTop + (slideDistance * doorSlidePos); // Slides down when open

            // Door panel (glass with frame)
            ctx.fillStyle = 'rgba(200, 230, 255, 0.6)'; // Light blue glass
            ctx.fillRect(doorX, doorPanelY, doorWidth, doorPanelHeight);

            // Door panel frame
            ctx.strokeStyle = '#4A3410';
            ctx.lineWidth = 4;
            ctx.strokeRect(doorX, doorPanelY, doorWidth, doorPanelHeight);

            // Glass reflection
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.fillRect(doorX + 5, doorPanelY + 5, 20, 30);

            // Handle/grip bar (horizontal bar in middle of door)
            const handleY = doorPanelY + doorPanelHeight / 2;
            ctx.fillStyle = '#C0C0C0';
            ctx.fillRect(doorX + 10, handleY - 3, doorWidth - 20, 6);
            ctx.strokeStyle = '#808080';
            ctx.lineWidth = 1;
            ctx.strokeRect(doorX + 10, handleY - 3, doorWidth - 20, 6);

            // Status indicator
            if (doorSlidePos > 0.5) {
                ctx.fillStyle = '#90EE90';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('OPEN', doorX + doorWidth / 2, doorFrameTop + doorFrameHeight / 2);
            }

            ctx.restore();
        }

        // Draw collection box in garden
        function drawCollectionBox() {
            const boxX = canvas.width * 0.75;
            const boxY = canvas.height - 150;
            const boxWidth = 100;
            const boxHeight = 100;

            // Draw box
            ctx.fillStyle = '#CD853F';
            ctx.fillRect(boxX - boxWidth / 2, boxY, boxWidth, boxHeight);

            // Box outline
            ctx.strokeStyle = '#8B4513';
            ctx.lineWidth = 3;
            ctx.strokeRect(boxX - boxWidth / 2, boxY, boxWidth, boxHeight);

            // Draw diagonal lines for 3D effect
            ctx.beginPath();
            ctx.moveTo(boxX - boxWidth / 2, boxY);
            ctx.lineTo(boxX - boxWidth / 2 + 10, boxY - 10);
            ctx.lineTo(boxX + boxWidth / 2 + 10, boxY - 10);
            ctx.lineTo(boxX + boxWidth / 2, boxY);
            ctx.closePath();
            ctx.fillStyle = '#DEB887';
            ctx.fill();
            ctx.stroke();

            // Label
            ctx.fillStyle = '#000000';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('TOY BOX', boxX, boxY - 15);

            // Draw collected toys inside the box
            collectedToys.forEach((toy, index) => {
                const row = Math.floor(index / 3);
                const col = index % 3;
                const toyX = boxX - 30 + col * 30;
                const toyY = boxY + 80 - row * 25;

                ctx.save();
                ctx.globalAlpha = 0.8;
                drawToy(toyX, toyY, toy, 0.7); // Smaller scale
                ctx.restore();
            });
        }

        let lastFrameTime = Date.now();

        function update() {
            if (!gameRunning) return;

            const currentTime = Date.now();
            const deltaTime = currentTime - lastFrameTime;
            lastFrameTime = currentTime;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw background image (responsive - portrait for phone, landscape for desktop)
            const isPortrait = canvas.width < canvas.height;
            const bgImage = isPortrait ? bgImagePortrait : bgImageLandscape;

            if (imagesLoaded === 2) {
                ctx.drawImage(bgImage, 0, 0, canvas.width, canvas.height);
            } else {
                // Fallback colors while loading
                ctx.fillStyle = '#D2B48C';
                ctx.fillRect(0, 0, canvas.width / 2, canvas.height);
                ctx.fillStyle = '#7cb342';
                ctx.fillRect(canvas.width / 2, 0, canvas.width / 2, canvas.height);
            }

            // Update door timer and animation
            doorTimer += deltaTime;
            if (doorTimer >= nextDoorChange) {
                doorOpen = !doorOpen;
                doorTimer = 0;
                nextDoorChange = 1000 + Math.random() * 2000; // 1-3 seconds
                doorAnimating = true;
            }

            // Animate door sliding
            if (doorAnimating) {
                if (doorOpen && doorSlidePos < 1) {
                    doorSlidePos += deltaTime / 500; // Slide open in 500ms
                    if (doorSlidePos >= 1) {
                        doorSlidePos = 1;
                        doorAnimating = false;
                    }
                } else if (!doorOpen && doorSlidePos > 0) {
                    doorSlidePos -= deltaTime / 500; // Slide closed in 500ms
                    if (doorSlidePos <= 0) {
                        doorSlidePos = 0;
                        doorAnimating = false;
                    }
                }
            }

            // Draw sliding door
            drawSlidingDoor();

            // Draw uncollected items
            houseItems.forEach(item => {
                if (!item.collected) {
                    drawToy(item.x, item.y, item.type);
                }
            });

            // Move Richard towards target
            const dx = richard.targetX - richard.x;
            const dy = richard.targetY - richard.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance > 2) {
                // Store previous position before moving
                richard.prevX = richard.x;
                const prevY = richard.y;

                // Move Richard
                richard.x += dx * richard.speed;
                richard.y += dy * richard.speed;

                // Wall boundaries
                const margin = 30;
                const leftWall = margin;
                const rightWall = canvas.width - margin;
                const topWall = margin;
                const bottomWall = canvas.height - margin;

                // Keep Richard within bounds
                richard.x = Math.max(leftWall, Math.min(rightWall, richard.x));
                richard.y = Math.max(topWall, Math.min(bottomWall, richard.y));

                // Check if trying to cross the center dividing wall/door
                const doorCenterX = canvas.width / 2;
                const prevSide = richard.prevX < doorCenterX ? 'left' : 'right';
                const newSide = richard.x < doorCenterX ? 'left' : 'right';
                const crossedDoor = prevSide !== newSide;

                // Door area bounds
                const doorTop = canvas.height / 2 - 60;
                const doorBottom = canvas.height / 2 + 60;
                const inDoorArea = richard.y >= doorTop && richard.y <= doorBottom;

                if (crossedDoor) {
                    // Trying to cross the center line
                    if (!inDoorArea) {
                        // Not in door area - hitting the solid wall above or below the door
                        // Lose a life for hitting the wall!
                        lives--;
                        document.getElementById('lives').textContent = lives;

                        richard.x = richard.prevX;
                        richard.targetX = richard.prevX;

                        // Flash the screen red briefly
                        ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);

                        // Check if game over
                        if (lives <= 0) {
                            gameRunning = false;
                            setTimeout(() => {
                                gameOver();
                            }, 500);
                            return;
                        }
                    } else if (!doorOpen) {
                        // In door area but door is closed - lose a life!
                        lives--;
                        document.getElementById('lives').textContent = lives;

                        // Push Richard back to their previous side
                        richard.x = richard.prevX;
                        richard.targetX = richard.prevX;

                        // Flash the screen red briefly
                        ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);

                        // Check if game over
                        if (lives <= 0) {
                            gameRunning = false; // Stop game immediately
                            setTimeout(() => {
                                gameOver();
                            }, 500);
                            return; // Exit update loop
                        }
                    }
                    // If inDoorArea && doorOpen, allow crossing
                }
            }

            // Draw Richard
            drawRichard(richard.x, richard.y);

            // Check item pickup (only in house, not carrying)
            if (!richard.carryingItem && richard.x < canvas.width / 2) {
                houseItems.forEach(item => {
                    if (!item.collected) {
                        const dist = Math.sqrt(
                            Math.pow(richard.x - item.x, 2) +
                            Math.pow(richard.y - item.y, 2)
                        );
                        if (dist < 30) {
                            item.collected = true;
                            richard.carryingItem = item.type; // Store the toy type
                        }
                    }
                });
            }

            // Check item delivery (in garden with item)
            // Deliver when Richard crosses into the garden side (past the center wall)
            if (richard.carryingItem && richard.x > canvas.width / 2 + 20) {
                collectedToys.push(richard.carryingItem); // Add to collected toys array
                richard.carryingItem = false;
                itemsCollected++;
                document.getElementById('itemsCollected').textContent = itemsCollected;

                if (itemsCollected >= totalItems) {
                    endGame();
                    return;
                }
            }

            requestAnimationFrame(update);
        }

        // Check if movement is blocked by closed door
        function isDoorBlocking(fromX, toX, y) {
            const doorCenterX = canvas.width / 2;
            const doorTop = canvas.height / 2 - 60;
            const doorBottom = canvas.height / 2 + 60;

            // Check if y position is near door
            const nearDoor = y >= doorTop && y <= doorBottom;
            if (!nearDoor) return false;

            // Check if trying to cross from one side to the other
            const fromSide = fromX < doorCenterX ? 'left' : 'right';
            const toSide = toX < doorCenterX ? 'left' : 'right';
            const crossingDoor = fromSide !== toSide;

            return crossingDoor && !doorOpen;
        }

        // Input handling
        canvas.addEventListener('click', (e) => {
            if (!gameRunning) return;

            const rect = canvas.getBoundingClientRect();
            const newTargetX = e.clientX - rect.left;
            const newTargetY = e.clientY - rect.top;

            // Only set target if not blocked by door
            if (!isDoorBlocking(richard.x, newTargetX, richard.y)) {
                richard.targetX = newTargetX;
                richard.targetY = newTargetY;
            }
        });

        canvas.addEventListener('touchstart', (e) => {
            if (!gameRunning) return;
            e.preventDefault();

            const rect = canvas.getBoundingClientRect();
            const newTargetX = e.touches[0].clientX - rect.left;
            const newTargetY = e.touches[0].clientY - rect.top;

            // Only set target if not blocked by door
            if (!isDoorBlocking(richard.x, newTargetX, richard.y)) {
                richard.targetX = newTargetX;
                richard.targetY = newTargetY;
            }
        });

        // Keyboard controls
        let keys = {};
        document.addEventListener('keydown', (e) => {
            keys[e.key] = true;
        });

        document.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        function handleKeyboard() {
            if (!gameRunning) return;

            const speed = 15; // Increased from 5 to 15 for faster movement
            let newTargetX = richard.targetX;
            let newTargetY = richard.targetY;

            if (keys['ArrowUp'] || keys['w'] || keys['W']) newTargetY = richard.y - speed;
            if (keys['ArrowDown'] || keys['s'] || keys['S']) newTargetY = richard.y + speed;
            if (keys['ArrowLeft'] || keys['a'] || keys['A']) newTargetX = richard.x - speed;
            if (keys['ArrowRight'] || keys['d'] || keys['D']) newTargetX = richard.x + speed;

            // Keep within bounds
            newTargetX = Math.max(30, Math.min(canvas.width - 30, newTargetX));
            newTargetY = Math.max(30, Math.min(canvas.height - 30, newTargetY));

            // Only update target if not blocked by door
            if (!isDoorBlocking(richard.x, newTargetX, newTargetY)) {
                richard.targetX = newTargetX;
                richard.targetY = newTargetY;
            }

            requestAnimationFrame(handleKeyboard);
        }

        // Timer
        function startTimer() {
            gameTimer = 0;
            document.getElementById('timer').textContent = gameTimer;

            timerInterval = setInterval(() => {
                gameTimer++;
                document.getElementById('timer').textContent = gameTimer;
            }, 1000);
        }

        function stopTimer() {
            clearInterval(timerInterval);
        }

        // Game flow
        function startGame() {
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('controlsHint').style.display = 'block';

            gameRunning = true;
            itemsCollected = 0;
            lives = 3;
            document.getElementById('itemsCollected').textContent = itemsCollected;
            document.getElementById('lives').textContent = lives;

            richard.x = canvas.width * 0.75;
            richard.y = canvas.height / 2;
            richard.targetX = richard.x;
            richard.targetY = richard.y;
            richard.prevX = richard.x;
            richard.carryingItem = false;

            doorOpen = false;
            doorTimer = 0;
            nextDoorChange = 2000;
            lastFrameTime = Date.now();

            generateItems();
            startTimer();
            update();
            handleKeyboard();

            setTimeout(() => {
                document.getElementById('controlsHint').style.display = 'none';
            }, 5000);
        }

        async function gameOver() {
            gameRunning = false;
            stopTimer();

            document.getElementById('gameOverTitle').textContent = 'üíî Game Over!';
            document.getElementById('finalTime').textContent = gameTimer;

            const highScoreMsg = document.getElementById('highScoreMessage');
            highScoreMsg.textContent = `You ran out of lives! Collected ${itemsCollected}/${totalItems} toys`;
            highScoreMsg.style.color = '#ff6347';
            highScoreMsg.style.fontWeight = 'bold';

            // Load and display leaderboard
            await loadLeaderboard();

            document.getElementById('gameOverModal').style.display = 'block';
        }

        async function endGame() {
            gameRunning = false;
            stopTimer();

            const finalTime = gameTimer;
            document.getElementById('finalTime').textContent = finalTime;

            // Check if player won or lost
            const won = itemsCollected >= totalItems;

            if (won) {
                // Player completed the game
                const isNewHighScore = await saveHighScore(finalTime);

                const highScoreMsg = document.getElementById('highScoreMessage');
                if (isNewHighScore) {
                    highScoreMsg.textContent = 'üéä NEW PERSONAL BEST! üéä';
                    highScoreMsg.style.color = '#ff6347';
                    highScoreMsg.style.fontWeight = 'bold';
                } else if (userHighScore < Infinity) {
                    highScoreMsg.textContent = `Your best time: ${userHighScore}s`;
                    highScoreMsg.style.color = '#666';
                    highScoreMsg.style.fontWeight = 'normal';
                } else {
                    highScoreMsg.textContent = '';
                }

                document.getElementById('gameOverTitle').textContent = 'üéâ Great Job! üéâ';
            } else {
                // Player lost (ran out of lives)
                document.getElementById('gameOverTitle').textContent = 'üíî Game Over!';
                document.getElementById('highScoreMessage').textContent = 'You ran out of lives! Try again!';
                document.getElementById('highScoreMessage').style.color = '#ff6347';
                document.getElementById('highScoreMessage').style.fontWeight = 'bold';
            }

            // Load and display leaderboard
            await loadLeaderboard();

            document.getElementById('gameOverModal').style.display = 'block';
        }

        function restartGame() {
            document.getElementById('gameOverModal').style.display = 'none';
            startGame();
        }

        function goBack() {
            window.location.href = 'richard-index.html';
        }
    </script>
</body>
</html>
