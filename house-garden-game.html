<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>House & Garden - Cute Richard</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Comic Sans MS', 'Arial', sans-serif;
            background: linear-gradient(to right, #8B4513 0%, #8B4513 50%, #90EE90 50%, #90EE90 100%);
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: rgba(86, 171, 47, 0.9);
            color: white;
            padding: 15px;
            text-align: center;
            position: relative;
            z-index: 10;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }

        .header h1 {
            font-size: 1.8em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        .score-board {
            display: flex;
            justify-content: space-around;
            margin-top: 10px;
            font-size: 1.1em;
        }

        .game-container {
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        .modal {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 100;
            background: rgba(255, 255, 255, 0.98);
            padding: 40px;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            max-width: 500px;
            width: 90%;
        }

        .modal h2 {
            color: #56ab2f;
            margin-bottom: 20px;
            font-size: 2em;
        }

        .modal p {
            color: #666;
            margin-bottom: 20px;
            font-size: 1.1em;
        }

        .btn {
            background: linear-gradient(135deg, #56ab2f, #a8e063);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 1.3em;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            transition: all 0.3s ease;
            font-family: 'Comic Sans MS', 'Arial', sans-serif;
            margin: 5px;
        }

        .btn:hover {
            transform: scale(1.05);
            box-shadow: 0 7px 20px rgba(0,0,0,0.4);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #667eea, #764ba2);
        }

        .btn-small {
            padding: 10px 25px;
            font-size: 1.1em;
        }

        .controls-hint {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 15px 25px;
            border-radius: 15px;
            z-index: 5;
            font-size: 1.1em;
        }

        @media (max-width: 480px) {
            .header h1 {
                font-size: 1.4em;
            }
            .score-board {
                font-size: 0.9em;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üè† Richard's House & Garden üå≥</h1>
        <div class="score-board">
            <div>Player: <span id="playerName">...</span></div>
            <div>Items: <span id="itemsCollected">0</span>/10 üì¶</div>
            <div>Lives: <span id="lives">3</span> ‚ù§Ô∏è</div>
            <div>Time: <span id="timer">0</span>s ‚è±Ô∏è</div>
        </div>
    </div>

    <div class="game-container">
        <canvas id="gameCanvas"></canvas>

        <!-- Start Screen -->
        <div class="modal" id="startScreen">
            <h2>üê∂ Help Richard Fetch His Toys! üéæ</h2>
            <p>Move Richard between the house and garden!<br><br>
            üè† Grab toys from inside the house<br>
            üö™ Wait for the door to open (don't hit it!)<br>
            üå≥ Bring them to the garden area<br>
            ‚ù§Ô∏è You have 3 lives - be careful!<br><br>
            <strong>Controls:</strong> Click/Tap or Arrow Keys/WASD</p>
            <button class="btn" onclick="startGame()">Start Game!</button>
            <button class="btn btn-secondary btn-small" onclick="goBack()">Back to Menu</button>
        </div>

        <!-- Game Over Modal -->
        <div class="modal" id="gameOverModal">
            <h2 id="gameOverTitle">üéâ Great Job! üéâ</h2>
            <p id="gameOverText" style="font-size: 1.5em; color: #333;">
                Final Time: <span id="finalTime">0</span> seconds! üèÜ<br>
                <span id="highScoreMessage" style="font-size: 0.8em;"></span>
            </p>

            <button class="btn" onclick="restartGame()">Play Again</button>
            <button class="btn btn-secondary btn-small" onclick="goBack()">Back to Menu</button>
        </div>

        <div class="controls-hint" id="controlsHint">
            Click/Tap to move Richard or use Arrow Keys ‚å®Ô∏è
        </div>
    </div>

    <!-- Firebase SDK -->
    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
        import { getDatabase, ref, update, get } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js';

        const firebaseConfig = {
            apiKey: "AIzaSyDYrFZbFzAyoBBXJoX83Wq_CumP6NYie64",
            authDomain: "richardgame-67766.firebaseapp.com",
            databaseURL: "https://richardgame-67766-default-rtdb.firebaseio.com",
            projectId: "richardgame-67766",
            storageBucket: "richardgame-67766.firebasestorage.app",
            messagingSenderId: "886284486792",
            appId: "1:886284486792:web:f797fe51368861eab8f73d",
            measurementId: "G-D5K95ZN5GC"
        };

        const app = initializeApp(firebaseConfig);
        const database = getDatabase(app);

        window.firebaseDB = database;
        window.firebaseRef = ref;
        window.firebaseUpdate = update;
        window.firebaseGet = get;

        initializeUser();
    </script>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight - document.querySelector('.header').offsetHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // User management
        let userId = null;
        let userName = 'Player';
        let userHighScore = Infinity;

        function initializeUser() {
            const userDataStr = sessionStorage.getItem('richardUserData');
            if (userDataStr) {
                try {
                    const userData = JSON.parse(userDataStr);
                    userId = userData.userId;
                    userName = userData.userName || 'Player';
                    userHighScore = userData.highScores?.houseGarden || Infinity;
                    document.getElementById('playerName').textContent = userName;
                } catch (error) {
                    console.error('Error parsing user data:', error);
                }
            } else {
                alert('Please start from the main menu!');
                window.location.href = 'richard-index.html';
                return;
            }

            document.getElementById('startScreen').style.display = 'block';
        }

        async function saveHighScore(timeTaken) {
            if (timeTaken < userHighScore) {
                userHighScore = timeTaken;

                const userDataStr = sessionStorage.getItem('richardUserData');
                if (userDataStr) {
                    const userData = JSON.parse(userDataStr);
                    userData.highScores = userData.highScores || {};
                    userData.highScores.houseGarden = timeTaken;
                    sessionStorage.setItem('richardUserData', JSON.stringify(userData));
                }

                const localData = JSON.parse(localStorage.getItem('richardUserProfile') || '{}');
                localData.highScores = localData.highScores || {};
                localData.highScores.houseGarden = timeTaken;
                localStorage.setItem('richardUserProfile', JSON.stringify(localData));

                try {
                    const userRef = window.firebaseRef(window.firebaseDB, 'users/' + userId + '/highScores');
                    await window.firebaseUpdate(userRef, {
                        houseGarden: timeTaken,
                        lastPlayed: Date.now()
                    });
                } catch (error) {
                    console.warn('Could not sync high score with Firebase:', error);
                }

                return true;
            }
            return false;
        }

        // Game variables
        let gameRunning = false;
        let itemsCollected = 0;
        let totalItems = 10;
        let gameTimer = 0;
        let timerInterval = null;
        let lives = 3;

        // Door state
        let doorOpen = false;
        let doorTimer = 0;
        let nextDoorChange = 2000; // milliseconds

        // Richard position
        let richard = {
            x: canvas.width * 0.75, // Start in garden
            y: canvas.height / 2,
            targetX: canvas.width * 0.75,
            targetY: canvas.height / 2,
            width: 60,
            height: 45,
            speed: 0.15,
            carryingItem: false,
            prevX: canvas.width * 0.75 // Track previous x position
        };

        // Items in house
        let houseItems = [];
        let collectedToys = []; // Toys that have been delivered to the box

        // Generate random items in house
        function generateItems() {
            houseItems = [];
            collectedToys = [];
            const houseLeft = 50;
            const houseRight = canvas.width / 2 - 100;
            const houseTop = 50;
            const houseBottom = canvas.height - 50;

            const toyTypes = ['bone', 'ball', 'fish', 'rope'];

            for (let i = 0; i < totalItems; i++) {
                houseItems.push({
                    x: houseLeft + Math.random() * (houseRight - houseLeft),
                    y: houseTop + Math.random() * (houseBottom - houseTop),
                    collected: false,
                    type: toyTypes[Math.floor(Math.random() * toyTypes.length)]
                });
            }
        }

        // Draw Richard
        function drawRichard(x, y) {
            ctx.save();

            // Body
            ctx.fillStyle = '#d4a373';
            ctx.beginPath();
            ctx.ellipse(x, y, 30, 18, 0, 0, Math.PI * 2);
            ctx.fill();

            // White belly
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.ellipse(x, y + 3, 18, 11, 0, 0, Math.PI * 2);
            ctx.fill();

            // Head
            ctx.fillStyle = '#d4a373';
            ctx.beginPath();
            ctx.ellipse(x - 18, y - 7, 15, 13, 0, 0, Math.PI * 2);
            ctx.fill();

            // White face
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.ellipse(x - 18, y - 6, 9, 7, 0, 0, Math.PI * 2);
            ctx.fill();

            // Eyes
            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.arc(x - 22, y - 9, 2, 0, Math.PI * 2);
            ctx.arc(x - 14, y - 9, 2, 0, Math.PI * 2);
            ctx.fill();

            // Nose
            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.arc(x - 18, y - 4, 3, 0, Math.PI * 2);
            ctx.fill();

            // Tail
            ctx.strokeStyle = '#d4a373';
            ctx.lineWidth = 5;
            ctx.beginPath();
            ctx.moveTo(x + 30, y);
            ctx.quadraticCurveTo(x + 37, y - 7, x + 33, y - 15);
            ctx.stroke();

            // If carrying item, draw toy above
            if (richard.carryingItem) {
                drawToy(x, y - 30, richard.carryingItem);
            }

            ctx.restore();
        }

        // Draw dog toy based on type
        function drawToy(x, y, type, scale = 1) {
            ctx.save();

            if (type === 'bone') {
                // Draw a bone
                ctx.fillStyle = '#F5DEB3';
                // Left end
                ctx.beginPath();
                ctx.arc(x - 12 * scale, y - 3 * scale, 4 * scale, 0, Math.PI * 2);
                ctx.arc(x - 12 * scale, y + 3 * scale, 4 * scale, 0, Math.PI * 2);
                ctx.fill();
                // Right end
                ctx.beginPath();
                ctx.arc(x + 12 * scale, y - 3 * scale, 4 * scale, 0, Math.PI * 2);
                ctx.arc(x + 12 * scale, y + 3 * scale, 4 * scale, 0, Math.PI * 2);
                ctx.fill();
                // Middle
                ctx.fillRect(x - 10 * scale, y - 2 * scale, 20 * scale, 4 * scale);

            } else if (type === 'ball') {
                // Draw a tennis ball
                ctx.fillStyle = '#CCFF00';
                ctx.beginPath();
                ctx.arc(x, y, 10 * scale, 0, Math.PI * 2);
                ctx.fill();
                // Tennis ball lines
                ctx.strokeStyle = '#FFFFFF';
                ctx.lineWidth = 2 * scale;
                ctx.beginPath();
                ctx.arc(x, y, 10 * scale, Math.PI * 0.3, Math.PI * 0.7);
                ctx.arc(x, y, 10 * scale, Math.PI * 1.3, Math.PI * 1.7);
                ctx.stroke();

            } else if (type === 'fish') {
                // Draw a toy fish
                ctx.fillStyle = '#4169E1';
                // Body
                ctx.beginPath();
                ctx.ellipse(x, y, 12 * scale, 6 * scale, 0, 0, Math.PI * 2);
                ctx.fill();
                // Tail
                ctx.beginPath();
                ctx.moveTo(x + 12 * scale, y);
                ctx.lineTo(x + 18 * scale, y - 5 * scale);
                ctx.lineTo(x + 18 * scale, y + 5 * scale);
                ctx.closePath();
                ctx.fill();
                // Eye
                ctx.fillStyle = '#000000';
                ctx.beginPath();
                ctx.arc(x - 6 * scale, y - 2 * scale, 2 * scale, 0, Math.PI * 2);
                ctx.fill();

            } else if (type === 'rope') {
                // Draw a rope toy
                ctx.strokeStyle = '#CD853F';
                ctx.lineWidth = 6 * scale;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(x - 12 * scale, y - 4 * scale);
                ctx.quadraticCurveTo(x - 4 * scale, y + 4 * scale, x + 4 * scale, y - 4 * scale);
                ctx.quadraticCurveTo(x + 12 * scale, y + 4 * scale, x + 15 * scale, y);
                ctx.stroke();
                // Frayed ends
                ctx.lineWidth = 2 * scale;
                ctx.beginPath();
                ctx.moveTo(x - 15 * scale, y - 6 * scale);
                ctx.lineTo(x - 12 * scale, y - 4 * scale);
                ctx.moveTo(x - 14 * scale, y - 2 * scale);
                ctx.lineTo(x - 12 * scale, y - 4 * scale);
                ctx.moveTo(x + 15 * scale, y - 2 * scale);
                ctx.lineTo(x + 18 * scale, y - 4 * scale);
                ctx.moveTo(x + 15 * scale, y + 2 * scale);
                ctx.lineTo(x + 18 * scale, y + 4 * scale);
                ctx.stroke();
            }

            ctx.restore();
        }

        // Draw door
        function drawDoor() {
            const doorX = canvas.width / 2 - 40;
            const doorY = canvas.height / 2 - 60;
            const doorWidth = 80;
            const doorHeight = 120;

            // Door frame
            ctx.fillStyle = '#654321';
            ctx.fillRect(doorX, doorY, doorWidth, doorHeight);

            if (doorOpen) {
                // Open door - show opening
                ctx.fillStyle = '#000000';
                ctx.fillRect(doorX + 10, doorY + 10, doorWidth - 20, doorHeight - 20);
                ctx.fillStyle = '#90EE90';
                ctx.font = '20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('OPEN', doorX + doorWidth / 2, doorY + doorHeight / 2);
            } else {
                // Closed door
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(doorX + 5, doorY + 5, doorWidth - 10, doorHeight - 10);
                // Door knob
                ctx.fillStyle = '#FFD700';
                ctx.beginPath();
                ctx.arc(doorX + doorWidth - 20, doorY + doorHeight / 2, 5, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Draw collection box in garden
        function drawCollectionBox() {
            const boxX = canvas.width * 0.75;
            const boxY = canvas.height - 150;
            const boxWidth = 100;
            const boxHeight = 100;

            // Draw box
            ctx.fillStyle = '#CD853F';
            ctx.fillRect(boxX - boxWidth / 2, boxY, boxWidth, boxHeight);

            // Box outline
            ctx.strokeStyle = '#8B4513';
            ctx.lineWidth = 3;
            ctx.strokeRect(boxX - boxWidth / 2, boxY, boxWidth, boxHeight);

            // Draw diagonal lines for 3D effect
            ctx.beginPath();
            ctx.moveTo(boxX - boxWidth / 2, boxY);
            ctx.lineTo(boxX - boxWidth / 2 + 10, boxY - 10);
            ctx.lineTo(boxX + boxWidth / 2 + 10, boxY - 10);
            ctx.lineTo(boxX + boxWidth / 2, boxY);
            ctx.closePath();
            ctx.fillStyle = '#DEB887';
            ctx.fill();
            ctx.stroke();

            // Label
            ctx.fillStyle = '#000000';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('TOY BOX', boxX, boxY - 15);

            // Draw collected toys inside the box
            collectedToys.forEach((toy, index) => {
                const row = Math.floor(index / 3);
                const col = index % 3;
                const toyX = boxX - 30 + col * 30;
                const toyY = boxY + 80 - row * 25;

                ctx.save();
                ctx.globalAlpha = 0.8;
                drawToy(toyX, toyY, toy, 0.7); // Smaller scale
                ctx.restore();
            });
        }

        let lastFrameTime = Date.now();

        function update() {
            if (!gameRunning) return;

            const currentTime = Date.now();
            const deltaTime = currentTime - lastFrameTime;
            lastFrameTime = currentTime;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw house side (left half - brown)
            ctx.fillStyle = '#D2B48C';
            ctx.fillRect(0, 0, canvas.width / 2, canvas.height);

            // Draw garden side (right half - green)
            ctx.fillStyle = '#7cb342';
            ctx.fillRect(canvas.width / 2, 0, canvas.width / 2, canvas.height);

            // Draw dividing wall (with gap for door)
            const doorCenterY = canvas.height / 2;
            const doorHeight = 120;
            const wallX = canvas.width / 2;

            ctx.fillStyle = '#654321'; // Dark brown wall
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 3;

            // Wall above door
            ctx.fillRect(wallX - 10, 0, 20, doorCenterY - doorHeight / 2);
            ctx.strokeRect(wallX - 10, 0, 20, doorCenterY - doorHeight / 2);

            // Wall below door
            ctx.fillRect(wallX - 10, doorCenterY + doorHeight / 2, 20, canvas.height - (doorCenterY + doorHeight / 2));
            ctx.strokeRect(wallX - 10, doorCenterY + doorHeight / 2, 20, canvas.height - (doorCenterY + doorHeight / 2));

            // Update door timer
            doorTimer += deltaTime;
            if (doorTimer >= nextDoorChange) {
                doorOpen = !doorOpen;
                doorTimer = 0;
                nextDoorChange = 1000 + Math.random() * 2000; // 1-3 seconds
            }

            // Draw collection box in garden
            drawCollectionBox();

            // Draw door
            drawDoor();

            // Draw uncollected items
            houseItems.forEach(item => {
                if (!item.collected) {
                    drawToy(item.x, item.y, item.type);
                }
            });

            // Move Richard towards target
            const dx = richard.targetX - richard.x;
            const dy = richard.targetY - richard.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance > 2) {
                // Store previous position before moving
                richard.prevX = richard.x;
                const prevY = richard.y;

                // Move Richard
                richard.x += dx * richard.speed;
                richard.y += dy * richard.speed;

                // Wall boundaries
                const margin = 30;
                const leftWall = margin;
                const rightWall = canvas.width - margin;
                const topWall = margin;
                const bottomWall = canvas.height - margin;

                // Keep Richard within bounds
                richard.x = Math.max(leftWall, Math.min(rightWall, richard.x));
                richard.y = Math.max(topWall, Math.min(bottomWall, richard.y));

                // Check if trying to cross the center dividing wall/door
                const doorCenterX = canvas.width / 2;
                const prevSide = richard.prevX < doorCenterX ? 'left' : 'right';
                const newSide = richard.x < doorCenterX ? 'left' : 'right';
                const crossedDoor = prevSide !== newSide;

                // Door area bounds
                const doorTop = canvas.height / 2 - 60;
                const doorBottom = canvas.height / 2 + 60;
                const inDoorArea = richard.y >= doorTop && richard.y <= doorBottom;

                if (crossedDoor) {
                    // Trying to cross the center line
                    if (!inDoorArea) {
                        // Not in door area - hitting the wall above or below the door
                        richard.x = richard.prevX;
                        richard.targetX = richard.prevX;
                    } else if (!doorOpen) {
                        // In door area but door is closed - lose a life!
                        lives--;
                        document.getElementById('lives').textContent = lives;

                        // Push Richard back to their previous side
                        richard.x = richard.prevX;
                        richard.targetX = richard.prevX;

                        // Flash the screen red briefly
                        ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);

                        // Check if game over
                        if (lives <= 0) {
                            gameRunning = false; // Stop game immediately
                            setTimeout(() => {
                                gameOver();
                            }, 500);
                            return; // Exit update loop
                        }
                    }
                    // If inDoorArea && doorOpen, allow crossing
                }
            }

            // Draw Richard
            drawRichard(richard.x, richard.y);

            // Check item pickup (only in house, not carrying)
            if (!richard.carryingItem && richard.x < canvas.width / 2) {
                houseItems.forEach(item => {
                    if (!item.collected) {
                        const dist = Math.sqrt(
                            Math.pow(richard.x - item.x, 2) +
                            Math.pow(richard.y - item.y, 2)
                        );
                        if (dist < 30) {
                            item.collected = true;
                            richard.carryingItem = item.type; // Store the toy type
                        }
                    }
                });
            }

            // Check item delivery (in garden with item)
            if (richard.carryingItem && richard.x > canvas.width / 2 + 50) {
                collectedToys.push(richard.carryingItem); // Add to collected toys array
                richard.carryingItem = false;
                itemsCollected++;
                document.getElementById('itemsCollected').textContent = itemsCollected;

                if (itemsCollected >= totalItems) {
                    endGame();
                    return;
                }
            }

            requestAnimationFrame(update);
        }

        // Check if movement is blocked by closed door
        function isDoorBlocking(fromX, toX, y) {
            const doorCenterX = canvas.width / 2;
            const doorTop = canvas.height / 2 - 60;
            const doorBottom = canvas.height / 2 + 60;

            // Check if y position is near door
            const nearDoor = y >= doorTop && y <= doorBottom;
            if (!nearDoor) return false;

            // Check if trying to cross from one side to the other
            const fromSide = fromX < doorCenterX ? 'left' : 'right';
            const toSide = toX < doorCenterX ? 'left' : 'right';
            const crossingDoor = fromSide !== toSide;

            return crossingDoor && !doorOpen;
        }

        // Input handling
        canvas.addEventListener('click', (e) => {
            if (!gameRunning) return;

            const rect = canvas.getBoundingClientRect();
            const newTargetX = e.clientX - rect.left;
            const newTargetY = e.clientY - rect.top;

            // Only set target if not blocked by door
            if (!isDoorBlocking(richard.x, newTargetX, richard.y)) {
                richard.targetX = newTargetX;
                richard.targetY = newTargetY;
            }
        });

        canvas.addEventListener('touchstart', (e) => {
            if (!gameRunning) return;
            e.preventDefault();

            const rect = canvas.getBoundingClientRect();
            const newTargetX = e.touches[0].clientX - rect.left;
            const newTargetY = e.touches[0].clientY - rect.top;

            // Only set target if not blocked by door
            if (!isDoorBlocking(richard.x, newTargetX, richard.y)) {
                richard.targetX = newTargetX;
                richard.targetY = newTargetY;
            }
        });

        // Keyboard controls
        let keys = {};
        document.addEventListener('keydown', (e) => {
            keys[e.key] = true;
        });

        document.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        function handleKeyboard() {
            if (!gameRunning) return;

            const speed = 15; // Increased from 5 to 15 for faster movement
            let newTargetX = richard.targetX;
            let newTargetY = richard.targetY;

            if (keys['ArrowUp'] || keys['w'] || keys['W']) newTargetY = richard.y - speed;
            if (keys['ArrowDown'] || keys['s'] || keys['S']) newTargetY = richard.y + speed;
            if (keys['ArrowLeft'] || keys['a'] || keys['A']) newTargetX = richard.x - speed;
            if (keys['ArrowRight'] || keys['d'] || keys['D']) newTargetX = richard.x + speed;

            // Keep within bounds
            newTargetX = Math.max(30, Math.min(canvas.width - 30, newTargetX));
            newTargetY = Math.max(30, Math.min(canvas.height - 30, newTargetY));

            // Only update target if not blocked by door
            if (!isDoorBlocking(richard.x, newTargetX, newTargetY)) {
                richard.targetX = newTargetX;
                richard.targetY = newTargetY;
            }

            requestAnimationFrame(handleKeyboard);
        }

        // Timer
        function startTimer() {
            gameTimer = 0;
            document.getElementById('timer').textContent = gameTimer;

            timerInterval = setInterval(() => {
                gameTimer++;
                document.getElementById('timer').textContent = gameTimer;
            }, 1000);
        }

        function stopTimer() {
            clearInterval(timerInterval);
        }

        // Game flow
        function startGame() {
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('controlsHint').style.display = 'block';

            gameRunning = true;
            itemsCollected = 0;
            lives = 3;
            document.getElementById('itemsCollected').textContent = itemsCollected;
            document.getElementById('lives').textContent = lives;

            richard.x = canvas.width * 0.75;
            richard.y = canvas.height / 2;
            richard.targetX = richard.x;
            richard.targetY = richard.y;
            richard.prevX = richard.x;
            richard.carryingItem = false;

            doorOpen = false;
            doorTimer = 0;
            nextDoorChange = 2000;
            lastFrameTime = Date.now();

            generateItems();
            startTimer();
            update();
            handleKeyboard();

            setTimeout(() => {
                document.getElementById('controlsHint').style.display = 'none';
            }, 5000);
        }

        function gameOver() {
            gameRunning = false;
            stopTimer();

            document.getElementById('gameOverTitle').textContent = 'Game Over!';
            document.getElementById('gameOverText').innerHTML =
                `You ran out of lives!<br><br>Items collected: ${itemsCollected}/${totalItems} üì¶<br>Time survived: ${gameTimer}s ‚è±Ô∏è`;

            const highScoreMsg = document.getElementById('highScoreMessage');
            highScoreMsg.textContent = '';
            highScoreMsg.style.color = '#666';
            highScoreMsg.style.fontWeight = 'normal';

            document.getElementById('gameOverModal').style.display = 'block';
        }

        async function endGame() {
            gameRunning = false;
            stopTimer();

            const finalTime = gameTimer;
            document.getElementById('finalTime').textContent = finalTime;

            const isNewHighScore = await saveHighScore(finalTime);

            const highScoreMsg = document.getElementById('highScoreMessage');
            if (isNewHighScore) {
                highScoreMsg.textContent = 'üéä NEW PERSONAL BEST! üéä';
                highScoreMsg.style.color = '#ff6347';
                highScoreMsg.style.fontWeight = 'bold';
            } else if (userHighScore < Infinity) {
                highScoreMsg.textContent = `Your best time: ${userHighScore}s`;
                highScoreMsg.style.color = '#666';
                highScoreMsg.style.fontWeight = 'normal';
            } else {
                highScoreMsg.textContent = '';
            }

            document.getElementById('gameOverTitle').textContent = 'üéâ Great Job! üéâ';
            document.getElementById('gameOverText').innerHTML =
                `Final Time: ${finalTime} seconds! üèÜ<br>
                <span id="highScoreMessage">${highScoreMsg.innerHTML}</span>`;

            document.getElementById('gameOverModal').style.display = 'block';
        }

        function restartGame() {
            document.getElementById('gameOverModal').style.display = 'none';
            startGame();
        }

        function goBack() {
            window.location.href = 'richard-index.html';
        }
    </script>
</body>
</html>
